import { For, createEffect, createMemo, createSignal, onMount, untrack } from "solid-js";
import { useNavigate, useSearchParams } from "solid-start";
import ClassesTable from "~/components/ClassesTable";
import { categories } from "~/constants";
import { tCategory, tSubs } from "~/i18n/dict";
import { Class, Course, Teacher } from "~/types";
// import { makeData } from "~/utils/makeData";
import { tapClasses } from "~/utils/someData";

import { ComboBox } from "~/components/ComboBox3";
import { Icon } from "solid-heroicons";
import { xCircle } from "solid-heroicons/solid";
import { getClasses, getTeachers } from "~/data/directus";

type CourseCategories = {
  [category: string]: Course[];
};

const myCourse = {
  id: "1",
  title: "title",
  category: "category",
  subCategory: "subCategory",
  startTime: "startTime",
  weekDays: ["weekDays"],
  duration: 1,
  level: "level",
  teacher: "teacher",
  icon: <div>icon</div>,
};

type CourseCategoryState = {
  [category: string]: Course[];
};

type WithSubCategory = {
  [category: string | number]: {
    [subCategory: string | number]: Course[];
  };
};

export default function Horarios() {
  const [query, setQuery] = createSignal<string>();
  const [searchParams, setSearchParams] = useSearchParams();
  const [classes, setClasses] = createSignal<Class[]>();
  const [teachers, setTeachers] = createSignal<Teacher[]>();

  // const [selectedCategories, setSelectedCategories] = createSignal<string[]>(
  //   []
  // );
  const [selectedCategory, setSelectedCategory] = createSignal<string>();
  const [selectedTeacher, setSelectedTeacher] = createSignal<string>();
  const [selectedTimeRange, setSelectedTimeRange] = createSignal("");

  // categories[0]

  const [selectionStore, setSelectionStore] = createSignal<
    Record<string, string>
  >({});

  const selected = searchParams.c?.split("|");
  // const initialData: Class[] = untrack(async () => classes);

  const [filteredData, setFilteredData] = createSignal<WithSubCategory>({});
  const [filteredCategories, setFilteredCategories] = createSignal<string[][]>(
    []
  );

  onMount(async () => {
    const [classes, teachers] = await Promise.all([getClasses(), getTeachers()])
  })

  createEffect(() => {
    const cat = selectedCategory();
    const teacher = selectedTeacher();

    const data =
      !cat && !teacher
        ? {}
        : untrack(() =>
            classes()?.reduce((acc, row) => {
              if (cat && row.category !== cat) {
                return acc;
              }
              if (teacher && !row.teachers.includes(teacher)) {
                return acc;
              }

              row.selected = selected?.includes(row.id) || false;

              const category = row["category"];

              const subCategory =
                !row["subCategory"] || row["subCategory"] == ""
                  ? "default"
                  : row["subCategory"];

              if (!acc[category]) {
                acc[category] = {};
              }

              if (!acc[category][subCategory]) {
                acc[category][subCategory] = [];
              }

              acc[category][subCategory].push(row);
              return acc;
            }, {} as WithSubCategory)
          );

    const uniqueCategories = new Set<string>();
    const uniqueSubCategories = new Set<string>();

    for (const categoryKey in data) {
      const category = categoryKey as string;
      uniqueCategories.add(category);

      const subCategoriesObj = data[category];

      for (const subCategoryKey in subCategoriesObj) {
        const subCategory = subCategoryKey as string;
        uniqueSubCategories.add(subCategory);
      }
    }

    // Convert uniqueCategories and uniqueSubCategories to an array of arrays
    const categoriesArray = Array.from(uniqueCategories).map((category) => [
      category,
      ...Array.from(uniqueSubCategories),
    ]);

    console.log(
      "change ...",
      selectedCategory(),
      selectedTeacher(),
      categoriesArray,
      data.length,
      data
    );
    setFilteredCategories(categoriesArray);
    setFilteredData(data);
  });

  const navigate = useNavigate();

  // createEffect(() => {
  //   const QueryValue = Object.values(selectionStore()).filter((v) => !!v);
  //   // .join("|");
  //   setQuery(QueryValue.join("|"));
  //   console.log("QueryValue", QueryValue);
  //   // setSearchParams({ c: QueryValue });

  //   const params = new URLSearchParams();
  //   // if (QueryValue) {
  //   params.append("xx", QueryValue.join("|"));
  //   // } else {
  //   // params.delete("xx");
  //   console.log("navigate", params);
  //   // }
  //   // history.push({ search: params.toString() });
  //   navigate("/?query=" + QueryValue.join("|"), { resolve: false });
  // });

  // const subCategories = createMemo(() => {
  //   const selected = selectedCategory() || "";
  //   const subSelected = !filteredData()[selected]
  //     ? []
  //     : Object.keys(filteredData()[selected]);

  //   return subSelected;
  // });

  const teacherset = [...new Set(tapClasses.flatMap((t) => t.teacher))].sort();

  return (
    <main
      class="mx-auto flex max-w-7xl items-center justify-between md:p-6 lg:px-8"
      aria-label="Global"

      // class="text-center mx-auto text-gray-700 p-4"
    >
      <div class="prose mx-auto ">
        <div class="flex flex-col gap-2">
          <ComboBox
            options={categories.map((o) => ({
              label: tCategory(o),
              value: o,
            }))}
            selected={selectedCategory}
            setSelected={setSelectedCategory}
            placeholder="Select a category"
          />

          <ComboBox
            options={Object.keys(teachers).map((teacherKey) => ({
              label: (teachers as any)[teacherKey] || teacherKey,
              value: teacherKey,
            }))}
            selected={selectedTeacher}
            setSelected={setSelectedTeacher}
            placeholder="Filter by teacher"
          />
        </div>

        <div>
          selected....{[selectedCategory(), selectedTeacher()].join(",")}
          <For each={filteredCategories()}>
            {(category) => (
              <>
                {/* {selectedCategory() === category && ( */}
                <h2 id={category[0]} class="px-2">
                  {tCategory(category[0])}
                </h2>
                {/* )} */}
                <For each={category.slice(1)}>
                  {(subCategory) => {
                    console.log(
                      "filtered",
                      filteredData(),
                      category,
                      subCategory
                    );
                    return (
                      filteredData()[category[0]][subCategory]?.length > 0 && (
                        <div>
                          {subCategory != "default" && (
                            <h3 class="px-4 text-slate-400">
                              {tSubs(subCategory)}
                            </h3>
                          )}
                          <ClassesTable
                            category={category[0] || ""}
                            subCategory={subCategory}
                            data={() =>
                              filteredData()[category[0] || ""][subCategory]
                            }
                            setSelectionStore={setSelectionStore}
                            selectionStore={selectionStore}
                            highlightTerms={
                              selectedTeacher()
                                ? [selectedTeacher() as string]
                                : undefined
                            }
                          />
                        </div>
                      )
                    );
                  }}
                </For>
              </>
            )}
          </For>
        </div>
      </div>
      <span class="h-20">.</span>
    </main>
  );
}

{
  /* <CategoryClasses
                category={category}
                data={() => dataByCategoryStore[category]}
              /> */
}
